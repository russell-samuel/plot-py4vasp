"""A plotting toolkit based on py4vasp 

Example
-------
The code can be directly used:

  $ python result.py
"""

import os, time
import re
# import fnmatch

import py4vasp, plotly
from selenium import webdriver, common
import plotly.express as px
# import numpy as np
# from multiprocessing import Event, Process, Pool


class Result():
  """A plotting tool based on py4vasp.

  One instance of this Class represents exactly one calculation result. 

  Note
  ----
  It is possible that opening a webpage in browser once an instance is 
  successfully created, and will be closed before the instance is destroyed. 

  Examples
  --------
  Basic Usage
  >>> # Create an instance of Result
  >>> r = Result("/path/to/folder")
  >>> # # If KPOINTS_OPT is used
  >>> # r.update_kpoints_file('kpoints_opt')
  >>> # Select projection of orbits
  >>> r.update_selection("up, down")
  >>> # Set range of axes
  >>> r.update_axis_range(y=(-2, 2))
  >>> # Set band width
  >>> r.update_fat_band_width(0.05)
  >>> # Preview the plot interactively
  >>> r.show_band()
  >>> r.show_dos()

  Get Image Files
  >>> # Set the image size
  >>> r.update_img_size(band=(1600, 1200), dos=(900, 1200))
  >>> # Set the image name
  >>> r.update_img_name(band='band-plot', dos='dos-plot')
  >>> # Set the image file format
  >>> r.update_img_fmt('png')
  >>> r.plot_band()
  >>> r.plot_dos()

  Thin Band Utility
  >>> # Turn on thin band mode, plot extremely thin band with hovertext
  >>> r.update_thin_band_mode('lines')

  DoS Rotation
  >>> # Swap the x- and y-axis of DoS plot
  >>> r.update_dos_rotated(True)

  Remove Total Channel of DoS
  >>> r.update_dos_nototal(True)

  Parameters
  ----------
  folder : str
    The path to folder that contains vaspout.h5. 

  Attributes
  ----------
  _FOLDER : str, CONSTANT
    The path to folder that contains vaspout.h5. 
  _FILE : py4vasp.raw.file.File, CONSTANT
    The opened vaspout.h5 file. 
  _RAW : dict, CONSTANT
    The raw data extracted from vaspout.h5 file, with the form:
      {
        'band' : py4vasp.raw.rawdata.RawBand, 
        'dos'  : py4vasp.raw.rawdata.RawDos, 
      }
  _DATA : dict, CONSTANT
    The data converted from raw data, with the form:
      {
        'band' : py4vasp.data.band.Band, 
        'dos'  : py4vasp.data.dos.Dos, 
      }
  _img : dict
    The plotly figure converted from data, with the form:
      {
        'band' : plotly.graph_objs._figure.Figure, 
        'dos'  : plotly.graph_objs._figure.Figure, 
      }
    Automatically be updated by `_update_img_band`/`_update_img_dos` method.
  kpoints_file : str
    The K-points file that used to be plotted. 
    Intend to be updated by `update_kpoints_file` method. 
  selection : str
    The projection of orbits. 
    Intend to be updated by `update_selection` method. 
  axis_range : dict
    The range of axes, with the form: 
    {
      'band' : {
        'x' : float, 
        'y' : float, 
      }, 
      'dos' : {
        'x' : float, 
        'y' : float, 
      }, 
    }
    Intend to be updated by `update_axis_range` method. 
  img_size : dict
    The size of image, with the form: 
    {
      'band' : tuple(int, int), 
      'dos'  : tuple(int, int), 
    }
    Intend to be updated by `update_img_size` method. 
  img_name : dict
    The name of image file, with the form: 
    {
      'band' : str, 
      'dos'  : str, 
    }
    Intend to be updated by `update_img_name` method. 
  img_title : dict
    The title of image file, with the form: 
    {
      'band' : str, 
      'dos'  : str, 
    }
    Intend to be updated by `update_img_title` method. 
  fat_band_width : float
    The width of band. 
    Intend to be updated by `update_fat_band_width` method. 
  thin_band_mode : str
    The switch of thin band utility. 
    Intend to be updated by `update_thin_band_mode` method. 
  THIN_BAND_WIDTH : float, CONSTANT
    The width of thin band. 
  dos_rotated : bool
    The switch of rotation on DoS plot. 
    Intend to be updated by `update_dos_rotated` method. 
  dos_nototal : bool
    The switch of removement of total channel of DoS plot. 
    Intend to be updated by `update_dos_nototal` method. 
  img_fmt : str
    The extension name of image file. 
    Intend to be updated by `update_img_fmt` method. 
  _html_files : list
    The list of html files generated by `plot_band`/`plot_dos` method. 
  _WAIT_TIME : float, CONSTANT
    The sleep time before starting cleaning defined in `__del__` method. 
  _drivers : list
    The list of successfully created webdriver. 
    The plotly html files will be opened by webdriver and auto-closed when 
    downloading finished. 
    If no webdriver in enviroment `os.environ`, then the plotly html files 
    will be opened in default browser and have to be manually closed. 
  """

  def __init__(self, folder:str) -> None:
    self._FOLDER : str                   = folder
    try:
      self._FILE   : py4vasp.raw.file.File = py4vasp.raw.File(self._FOLDER)
    except:
      print(f"{self._FOLDER} does NOT contain a h5 file!")
      exit()

    self._RAW : dict = {
      'band' : self._FILE.band['default'], 
      'dos'  : self._FILE.dos['default'], 
    }
    self._DATA : dict = {
      'band' : py4vasp.data.Band(self._RAW['band']), 
      'dos'  : py4vasp.data.Dos(self._RAW['dos']), 
    }

    self._img : dict = {
      'band' : None, 
      'dos'  : None, 
    }

    self.img_size : dict = {
      'band' : (1600, 1200), 
      'dos'  : (900, 1200), 
    }

    self.img_name : dict = {
      'band' : 'band-plot', 
      'dos'  : 'dos-plot', 
    }

    self.img_title : dict = {
      'band' : self._FOLDER, 
      'dos'  : self._FOLDER, 
    }

    self.kpoints_file : str = None
    self.selection : str = 'up, down'
      
    self.axis_range : dict = {
      'band' : {'x' : None, 'y' : None}, 
      'dos'  : {'x' : None, 'y' : None}
    }

    self.fat_band_width : float = 0.05
    self.thin_band_mode : str = 'none'
    # self.THIN_BAND_WIDTH : float = 1e-10
    ### for not that fat band
    self.THIN_BAND_WIDTH : float = 1e-2
      
    self.dos_rotated : bool = False
    self.dos_nototal : bool = False

    self.img_fmt : str = 'png'

    self._html_files : list = []
    self._WAIT_TIME : float = 2
    self._drivers = []

  ########################################

  def __repr__(self) -> str:
    """“official” string representation of an object.

    Called by the repr() built-in function to compute 
    the “official” string representation of an object.
    
    Examples
    --------
    >>> result = Result(folder="/path/to/folder")
    >>> # create the same instance via the representation
    >>> result_2 = eval(repr(result))
    >>> result == result_2
    True

    Returns
    -------
    str
      “official” string representation
    """

    args = [self._FOLDER]
    repr_str = "%s.%s(%s)" % (
      self.__class__.__module__,
      self.__class__.__qualname__,
      ", ".join(map(repr, args))
    )
    return repr_str

  # the diff __repr__ between __str__:
  # https://www.digitalocean.com/community/tutorials/python-str-repr-functions
  # https://www.pythonforbeginners.com/basics/__str__-vs-__repr#:~:text=According%20to%20the%20official%20Python%20documentation%2C%20__repr__%20is,used%20to%20represent%20objects%2C%20but%20in%20different%20ways.
  
  def __str__(self) -> str:
    """“inofficial” string representation of an object.

    Called by str(object) and the built-in functions format() and print() 
    to compute the “informal” or nicely printable string representation of an object
    
    Returns
    -------
    str
      “inofficial” string representation
    """

    img_band_name = f"{self.img_name['band']}{os.extsep}{self.img_fmt}"
    img_dos_name  = f"{self.img_name['dos']}{os.extsep}{self.img_fmt}"

    if self.kpoints_file == 'default':
      msg_kpoints_opt = "KPOINTS"
    elif self.kpoints_file == 'kpoints_opt':
      msg_kpoints_opt = "KPOINTS_OPT"

    if self.dos_nototal == True:
      msg_img_dos_nototal = "Removed"
    else:
      msg_img_dos_nototal = "Kept"

    return """Folder:
  %s
All:
  K-Points File: %s
  Projection of Orbits: %s
Band:
  Image Name: %s
  Image Size: %s x %s
  Axes Range: x = %s, y = %s
  Band Width: %s
  Thin Band Mode: %s
DoS:
  Image Name: %s
  Image Size: %s x %s
  Axes Range: x = %s, y = %s
  Rotated: %s
  Total Channel: %s
""" % (
      self._FOLDER, 

      msg_kpoints_opt, 
      self.selection, 

      img_band_name, 
      self.img_size['band'][0], self.img_size['band'][1], 
      self.axis_range['band']['x'], self.axis_range['band']['y'],  
      self.fat_band_width, 
      self.thin_band_mode, 

      img_dos_name, 
      self.img_size['dos'][0], self.img_size['dos'][1], 
      self.axis_range['dos']['x'], self.axis_range['dos']['y'], 
      self.dos_rotated, 
      msg_img_dos_nototal, 
  )
  
  def __del__(self) -> None:
    """Cleaning before destroying the instances
    """

    if self._drivers:
      time.sleep(self._WAIT_TIME)
      for driver in self._drivers:
        driver.close()
        # driver.quit()
      for file in self._html_files:
        os.remove(file)

  def update_img_fmt(self, fmt:str) -> None:
    """Update format of band/dos image. 

    the image format is used when plot_xxx() method is called

    Parameters
    ----------
    fmt : str
      the extension name of image file
      - None, this won't download image
      - 'png'
      - 'jpeg'
      - 'svg'
      - 'webp'
    """

    self.img_fmt = str(fmt)

  def update_img_name(self, all:str=None, band:str=None, dos:str=None) -> None:
    """Update the name of band/dos image

    Note
    ----
    the filename should exclude the extension name

    Parameters
    ----------
    all : str, opitonal
      the filename of all images
    band : str, opitonal
      the filename of band image
    dos : str, optional
      the filename of dos image
    """

    if all:
      for k in self.img_name.keys():
        self.img_name[k] = all
    if band:
      self.img_name['band'] = str(band)
    if dos:
      self.img_name['dos'] = str(dos)

  def update_img_size(self, all:str=None, band:tuple=None, dos:tuple=None) -> None:
    """Update size of band/dos image

    the image size is used when plot_xxx()/show_xxx() method is called

    Note
    ----
    a tuple contains two integers, for examples:
    - (1920, 1080), 1K/1080P/WSUVGA+/WSUGA/HDTV
    - (2560, 1440), 2K/1440P/QHD/WQHD
    - (3840, 2160), 4K/2160P/UHD

    Parameters
    ----------
    all : tuple, optional
      the size of all images
    band : tuple, optional
      the size of band image
    dos : tuple, optional
      the size of dos image
    """

    if all:
      for k in self.img_size.keys():
        self.img_size[k] = all
    if band:
      self.img_size['band'] = tuple(band)
    if dos:
      self.img_size['dos'] = tuple(dos)

  def update_img_title(self, all:str=None, band:str=None, dos:str=None) -> None:
    """Update the title of band/dos image

    Parameters
    ----------
    all : str, optional
      the title of all images
    band : str, opitonal
      the title of band image
    dos : str, optional
      the title of dos image
    """

    if all:
      for k in self.img_title.keys():
        self.img_title[k] = all
    if band:
      self.img_title['band'] = str(band)
    if dos:
      self.img_title['dos'] = str(dos)

  def update_axis_range(self, 
        x:tuple=None, y:tuple=None, 
        band_x:tuple=None, band_y:tuple=None,
        dos_x:tuple=None, dos_y:tuple=None, 
  ) -> None:
    """Update the range of y and/or x axis of dos image

    Note
    ----
    The axis range should be a tuple contains two integers, for example: (0, 1)

    If both x and band_x/dos_x are used, the band_x/dos_x will overwrite x, 
    the same for y and band_y/dos_y

    Parameters
    ----------
    x : tuple, optional
      range of x axis of all plots
    y : tuple, optional
      range of y axis of all plots
    band_x : tuple, optional
      range of x axis of band plot
    band_y : tuple, optional
      range of y axis of band plot
    dos_x : tuple, optional
      range of x axis of dos plot
    dos_y : tuple, optional
      range of y axis of dos plot
    """

    if x:
      self.axis_range['band']['x'] = self.axis_range['dos']['x'] = tuple(x)
    if y:
      self.axis_range['band']['y'] = self.axis_range['dos']['y'] = tuple(y)

    if band_x:
      self.axis_range['band']['x'] = tuple(band_x)
    if band_y:
      self.axis_range['band']['y'] = tuple(band_y)
    if dos_x:
      self.axis_range['dos']['x'] = tuple(dos_x)
    if dos_y:
      self.axis_range['dos']['y'] = tuple(dos_y)

  def _update_drivers(self) -> tuple:
    """Get a webdriver

    Try to create an instance of `selenium.webdriver.edge.webdriver.WebDrive` 

    Returns
    -------
    tuple
      An instance of `selenium.webdriver.edge.webdriver.WebDrive` if a 
      webdriver is successfully created. 
      And a Boolean value `True` if the creation of the  webdriver is 
      successful, otherwise `False`
    """
    try:
      #### comment Firefox if run into error
      options = webdriver.FirefoxOptions()
      options.add_argument('--headless')
      options.add_argument('--disable-gpu')
      options.set_preference('permissions.default.image',2)
      driver = webdriver.Firefox(options=options)
      # driver = webdriver.Firefox()
      ########################################
      ### and use Edge
      # driver = webdriver.Edge()
      ########################################
      auto_open = False
      self._drivers.append(driver)
    except common.exceptions.WebDriverException as e:
      driver = None
      auto_open = True
    return (driver, auto_open)

  ########################################

  def update_kpoints_file(self, use:str) -> None:
    """Use KPOINTS_OPT rather than KPOINTS to plot band/dos image

    Parameters
    ----------
    use : str
      - 'default', use KPOINTS to plot band/dos image
      - 'kpoints_opt', use KPOITNS_OPT to plot band/dos image
    """

    if use:
      self.kpoints_file = str(use)

  def update_selection(self, selection:str) -> None:
    """Update the projection of the orbitals of band image

    Parameters
    ----------
    selection : str
      the projection of the orbitals. 
      There are three distinct possibilities:
      - To specify the atom, you can either use its element name 
        (Si, Al, …) or its index as given in the input file (1, 2, …). 
        For the latter option it is also possible to specify ranges 
        (e.g. 1:4).
      - To select a particular orbital you can give a string (s, px, 
        dxz, …) or select multiple orbitals by their angular momentum (s, 
        p, d, f).
      - For the spin, you have the options up, down, or total.
        You separate multiple selections by commas or whitespace and can 
        nest them using parenthesis, e.g. Sr(s, p) or s(up), p(down). The 
        order of the selections does not matter, but it is case sensitive 
        to distinguish p (angular momentum l = 1) from P (phosphorus).
    """

    if selection:
      selection = re.sub('^ +|  +| +$', '', str(selection))
    else:
      selection = 'up, down'
    self.selection = selection

  ########################################

  def update_fat_band_width(self, width:float) -> None:
    """Update line width of band image

    Parameters
    ----------
    width : float
      the line width of band
    """

    self.fat_band_width = float(width)

  def update_thin_band_mode(self, mode:str) -> None:
    """Turn on/off thin band utility. 

    The band will be extremely thin with hovertext enabled

    Parameters
    ----------
    mode : str
      thin band mode 
      - Any combination of ['lines', 'markers', 'text'] joined 
        with '+' characters (e.g. 'lines+markers')
      - OR exactly one of ['none'] (e.g. 'none'), 
        this will also turn off thin band utility
    """

    self.thin_band_mode = str(mode).lower()

  def _update_img_band(self, action) -> None:
    """Update the band image to be plot
    """

    action = str(action).lower()

    # set selection, band width, K-points file
    if self.thin_band_mode != 'none': 
      width = self.THIN_BAND_WIDTH
    else:
      width = self.fat_band_width
    self._img['band'] = self._DATA['band'].to_plotly(
      selection = self.selection, 
      width     = width, 
      source    = self.kpoints_file, 
    )
    # set the background color
    # https://community.plotly.com/t/plot-background-how-can-i-setup-it/6617
    # plotly.graph_objs.Layout.plot_bgcolor
    self._img['band']['layout']['plot_bgcolor']='white'
    # self._img['band']['layout']['color_discrete_sequence']=['red', 'greed', 'blue']
    # self._img['band']['layout']['colorway']=['red', 'greed', 'blue']
    # self._img['band']['layout']['diverging']=['red', 'greed', 'blue']


    # plotly.graph_objs.layout.Colorscale
    colors = ['blue', 'red', 'olive']

    # https://www.jianshu.com/p/4f4daf47cc85
    # set band thin mode
    if self.thin_band_mode != 'none':
      # enable lable/hovertext
      # https://zhuanlan.zhihu.com/p/370656578
      for idx, scatter in enumerate(self._img['band']['data']):
        # remove fill between
        scatter['fill'] = None
        # add marker, to enable lable/hovertext
        scatter['mode'] = self.thin_band_mode
        # minimize the marker size
        scatter['marker'] = {'size': self.THIN_BAND_WIDTH, 'color': None}
        scatter['line'] = {'width': 1, 'color': colors[idx]}

        ##### for not that fat band
        ##### the self.THIN_BAND_WIDTH show also be modified to 1e-2
        # remove fill between
        scatter['fill'] = 'toself'
        scatter['fillcolor'] = colors[idx]
        # add marker, to enable lable/hovertext
        scatter['mode'] = self.thin_band_mode
        # minimize the marker size
        scatter['marker'] = {'size': self.THIN_BAND_WIDTH, 'color': None}
        scatter['line'] = {'color': colors[idx]}
        # print(scatter)
    else:
      for idx, scatter in enumerate(self._img['band']['data']):
        # custom fillin color
        scatter['fillcolor'] = colors[idx]

    # set range of x/y axis
    (
      self._img['band'].layout.xaxis.range, 
      self._img['band'].layout.yaxis.range
    ) = self.axis_range['band'].values()


    # https://blog.csdn.net/weixin_45826022/article/details/123154837
    # fig.add_vline()
    # fig.add_hline()
    # fig.add_vrect()
    # fig.add_hrect()
    for high_symmetry_point in self._img['band']['layout']['xaxis']['tickvals'][1:-1]:
      self._img['band'].add_vline(
        x          = high_symmetry_point, 
        line_width = 3, 
        line_dash  = "dash", 
        line_color = "black"
      )
    self._img['band'].add_hline(
        y          = 0, 
        line_width = 3, 
        line_dash  = "dash", 
        line_color = "black"
    )

    # axis line color, width
    # https://blog.csdn.net/weixin_45826022/article/details/122912484
    self._img['band']['layout']['xaxis']['linecolor'] = 'black'
    self._img['band']['layout']['yaxis']['linecolor'] = 'black'

    # set figure layout
    # layout title
    self._img['band'].layout.title.text = self.img_title['band']
    # layout font
    if action == 'plot': 
      w, h = self.img_size['band']
      font_size = w * h / 80000
      self._img['band'].layout.font.size = font_size
    # layout axis zeroline
    # plotly.graph_objs.layout.YAxis
    self._img['band'].layout.yaxis.zeroline = False
    self._img['band'].layout.yaxis.zerolinewidth = 1.5
    self._img['band'].layout.yaxis.zerolinecolor = 'grey'
    

  def show_band(self) -> None:
    """Show the band image in the browser
    """

    # init the image
    self._update_img_band(action='show')

    # show the band
    self._img['band'].show()
    
    # print the band information
    # self._DATA['band'].print()
  
  def plot_band(self) -> None:
    """Download the band image via the browser
    """

    # init the image
    self._update_img_band(action='plot')
    
    # set the image size
    w, h = self.img_size['band']
    # plot the image
    filename = f"temp-plot_{id(self._img['band'])}.html"

    (driver, auto_open) = self._update_drivers()
    
    plotly.offline.plot(
      figure_or_data = self._img['band'], 
      filename       = filename, 
      image_filename = self.img_name['band'],
      image          = self.img_fmt, 
      image_width    = w, 
      image_height   = h,
      auto_open      = auto_open, 
    )

    file_abs_path = os.path.abspath(filename)
    self._html_files.append(file_abs_path)
    if driver:
      driver.get(file_abs_path)

  ########################################

  def update_dos_rotated(self, rotated:bool) -> None:
    """Rotate DoS plot 90 degree 

    Parameters
    ----------
    rotated : bool
      - True, rotate the DoS plot 90 degree
      - False, default
    """
    
    self.dos_rotated = bool(rotated)

  def update_dos_nototal(self, nototal:bool) -> None:
    """Remove the total channel in DoS plot

    Parameters
    ----------
    notot : bool
      - True, the total channel in DoS plot will be removed
      - False, default
        
    """
    
    self.dos_nototal = bool(nototal)

  def _update_img_dos(self, action) -> None:
    """Update the dos image to be plot
    """
    
    action = str(action).lower()

    # set selection, K-points file
    self._img['dos'] = self._DATA['dos'].to_plotly(
      selection = self.selection, 
      source    = self.kpoints_file, 
    )

    # remove the total dos
    if self.dos_nototal == True and self.selection != 'up, down':
      self._img['dos'].data = self._img['dos'].data[2:]

    self._img['dos']['layout']['plot_bgcolor']='white'
    
    colors = ['blue', 'red', 'olive']
    for idx, scatter in enumerate(self._img['dos'].data):
      # scatter['mode'] = 'line'
      scatter['line'] = {'width': 3.5, 'color': colors[idx]}

    # rotate the dos
    if self.dos_rotated == True:
      # rotate the data
      for scatter in self._img['dos'].data:
        (
          scatter['x'], scatter['y']
        ) = (
          scatter['y'], scatter['x']
        )
      # swap x/y axis title
      (
        self._img['dos'].layout.xaxis.title.text, 
        self._img['dos'].layout.yaxis.title.text
      ) = (
        self._img['dos'].layout.yaxis.title.text, 
        self._img['dos'].layout.xaxis.title.text
      )

    # set range of x/y axis
    (
      self._img['dos'].layout.xaxis.range, 
      self._img['dos'].layout.yaxis.range
    ) = self.axis_range['dos'].values()

    # self._img['dos'].layout.xaxis.autorange = True

    # axis line color, width
    self._img['dos']['layout']['xaxis']['linecolor'] = 'black'
    self._img['dos']['layout']['yaxis']['linecolor'] = 'black'

    # set figure layout
    # layout title
    self._img['dos'].layout.title.text = self.img_title['dos']
    # layout font
    if action == 'plot': 
      w, h = self.img_size['dos']
      font_size = w * h / 45000
      self._img['dos'].layout.font.size = font_size
    # layout axis zeroline
    if self.dos_rotated == True:
      # self._img['dos'].layout.yaxis.zeroline = True
      # self._img['dos'].layout.yaxis.zerolinecolor = 'grey'
      self._img['dos'].add_hline(
          y          = 0, 
          line_width = 3, 
          line_dash  = "dash", 
          line_color = "black"
      )
    else:
      # self._img['dos'].layout.xaxis.zeroline = True
      # self._img['dos'].layout.xaxis.zerolinecolor = 'grey'
      self._img['dos'].add_vline(
        x          = 0, 
        line_width = 3, 
        line_dash  = "dash", 
        line_color = "black"
      )

  def show_dos(self) -> None:
    """Show the dos image in the browser
    """

    # init the image
    self._update_img_dos(action='show')

    # show the dos
    self._img['dos'].show()

    # print the dos information
    # self._DATA['dos'].print()

  def plot_dos(self) -> None:
    """Download the dos image via the browser
    """

    # init the image
    self._update_img_dos(action='plot')
    
    # set the image size
    w, h = self.img_size['dos']
    # plot the image
    filename = f"temp-plot_{id(self._img['dos'])}.html"

    (driver, auto_open) = self._update_drivers()
    
    plotly.offline.plot(
      figure_or_data = self._img['dos'], 
      filename       = filename, 
      image_filename = self.img_name['dos'],
      image          = self.img_fmt, 
      image_width    = w, 
      image_height   = h,
      auto_open      = auto_open, 
    )

    file_abs_path = os.path.abspath(filename)
    self._html_files.append(file_abs_path)
    if driver:
      driver.get(file_abs_path)


class Painter():
  pass
